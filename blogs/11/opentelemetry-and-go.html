<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>The complete guide to OpenTelemetry and Golang.</title>
    <meta name="description" content="The complete guide to OpenTelemetry and Golang." />
    <meta property="og:url" content="https://www.komu.engineer/blog" />

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ADD FAVICON -->

    <link rel="stylesheet" href="../../site.css">

    <!-- Get highlightjs by going to https://highlightjs.org/download/, select the languages you want and download. -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>

<body>
    <div class="container">
        <div class="header">
            <a href="https://www.komu.engineer">Home</a>&nbsp;&nbsp;
            <a href="https://www.komu.engineer/about">About Me</a>&nbsp;&nbsp;
            <a href="https://www.komu.engineer/blog">Blog</a>&nbsp;&nbsp;
        </div>
        <div class="left-sidebar">
            .
        </div>
        <div class="right-sidebar">
            .
        </div>

        <div class="main">
            <p>
                </br>
                <strong>The complete guide to OpenTelemetry and Golang. (15 Feb 2023)</strong>
                </br></br>
                This guide should take you from zero to production.</br>
                <a target="_blank" rel="noopener" href="https://opentelemetry.io/">OpenTelemetry</a> is a collection of
                tools that can be used to instrument, collect, and export telemetry(metrics, logs, & traces). That
                telemetry data can help you analyze your software's behavior. </br>
                At the end of this blogpost; </br>
            <ul>
                <li>Our application should be emitting logs, traces & metrics.</li>
                <li>We should be able to correlate logs to their corresponding traces.</li>
                <li>We should be able to correlate logs to their corresponding metrics.</li>
                <li>We should be able to correlate traces to their corresponding metrics.</li>
                <li>Our application should be able to propagate traces between different services.</li>
                <li>Telemetry should be collected in a secure, perfomant & scalable manner.</li>
            </ul>

            <strong id="Our application">Our application</strong></br>
            The application consists of two services(micro-services if you like); serviceA and serviceB. Customers
            send requests to serviceA, which in turn calls serviceB. </br>
            serviceB adds two numbers and returns the result inside the <i>SVC-RESPONSE</i> http header. serviceA echos
            back that header to the client/customer.
            <pre><code class="go">
package main

import (
    "context"
    "fmt"
    "net/http"
)

func main() {
    ctx := context.Background()
    go serviceA(ctx, 8081)
    serviceB(ctx, 8082)
}

func serviceA(ctx context.Context, port int) {
    mux := http.NewServeMux()
    mux.HandleFunc("/serviceA", serviceA_HttpHandler)
    serverPort := fmt.Sprintf(":%d", port)
    server := &http.Server{Addr: serverPort, Handler: mux}

    fmt.Println("serviceA listening on", server.Addr)
    if err := server.ListenAndServe(); err != nil {
        panic(err)
    }
}

func serviceA_HttpHandler(w http.ResponseWriter, r *http.Request) {
    cli := &http.Client{}
    req, err := http.NewRequestWithContext(r.Context(), http.MethodGet, "http://localhost:8082/serviceB", nil)
    if err != nil {
        panic(err)
    }
    resp, err := cli.Do(req)
    if err != nil {
        panic(err)
    }

    w.Header().Add("SVC-RESPONSE", resp.Header.Get("SVC-RESPONSE"))
}

func serviceB(ctx context.Context, port int) {
    mux := http.NewServeMux()
    mux.HandleFunc("/serviceB", serviceB_HttpHandler)
    serverPort := fmt.Sprintf(":%d", port)
    server := &http.Server{Addr: serverPort, Handler: mux}

    fmt.Println("serviceB listening on", server.Addr)
    if err := server.ListenAndServe(); err != nil {
        panic(err)
    }
}

func serviceB_HttpHandler(w http.ResponseWriter, r *http.Request) {
    answer := add(r.Context(), 42, 1813)
    w.Header().Add("SVC-RESPONSE", fmt.Sprint(answer))
    fmt.Fprintf(w, "hello from serviceB: Answer is: %d", answer)
}

func add(ctx context.Context, x, y int64) int64 { return x + y }                
            </code></pre>
            If we call serviceA, we get back;
            <pre><code class="go">
curl -I http://127.0.0.1:8081/serviceA

Svc-Response: 1855
            </code></pre>
            Perfect, everything is working.








            </br> </br>
        </div>
    </div>
</body>